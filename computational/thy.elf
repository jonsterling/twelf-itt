val : type.
use : type.
neu : type.
exp : type.
hyp : type.

%block hyp-b : block {x:hyp}.

` : hyp -> neu. %prefix 11 `.
@ : use -> neu -> neu. %infix right 10 @.
↓ : neu -> exp. %prefix 10 ↓.
↑ : val -> exp. %prefix 10 ↑.

unit : val.
ax : val.

prod : exp -> (hyp -> exp) -> val.
pair : exp -> exp -> val.
fst : use.
snd : use.

fun : exp -> exp -> val.
lam : (hyp -> exp) -> val.
ap : exp -> use.

let : exp -> (hyp -> exp) -> exp.

happ : use -> val -> exp -> type.
%mode happ +U +M -E.

uses : use -> val -> (hyp -> exp) -> type.
%mode uses +U +A -B.

%%% JUDGEMENTS FOR HYPOTHESES

%% x =>₀ A means "x is a hypothesis of type A"
=>₀ : hyp -> exp -> type. %infix left 9 =>₀.
%mode =>₀ +H -A.

%%% JUDGEMENTS FOR NORMAL FORMS

%% R => A means "R is a normal neutral term of type A"
=> : neu -> exp -> type. %infix left 9 =>.
%mode => +R -A.

%% M <=₀ A means "M is a normal value of type A"
<=₀ : val -> val -> type. %infix left 8 <=₀.
%mode <=₀ +M +A.

%% E <= A means "E is a normal expression of type A"
<= : exp -> exp -> type. %infix left 8 <=.
%mode <= +E +A.


%%% JUDGEMENTS FOR ANY TERMS

%% E <=* A means "E is an expression of type A"
<=* : exp -> exp -> type. %infix left 8 <=*.
%mode <=* +E +A.

%% R =>* A means "R is a neutral term of type A"
=>* : neu -> exp -> type. %infix left 8 =>*.
%mode =>* +R -A.

=>/@ : U @ R => A'
        <- R =>* ↑ A
        <- uses U A ([x] A').
=>/hyp : ` H => A
          <- H =>₀ A.

<=/↑ : ↑ M <= ↑ A
          <- M <=₀ A.
<=/↓ : ↓ R <= A
        <- R =>* A.


%%% HEREDITARY SUBSTITUTIONS 
hsubst-val : exp -> (hyp -> val) -> val -> type.
%mode hsubst-val +E +M -N.

hsubst-use : exp -> (hyp -> use) -> use -> type.
%mode hsubst-use +E +U -V.

hsubst-neu : exp -> (hyp -> neu) -> neu -> type.
%mode hsubst-neu +E +R -S.

hsubst-neu-exp : exp -> (hyp -> neu) -> exp -> type.
%mode hsubst-neu-exp +E +R -E'.

hsubst-exp : exp -> (hyp -> exp) -> exp -> type.
%mode hsubst-exp +E +F -E'.

hsubst/prod : hsubst-val E0 ([x] prod (A x) ([y] B x y)) (prod A' B')
               <- hsubst-exp E0 A A'
               <- {y} hsubst-exp E0 ([x] B x y) (B' y).
hsubst/pair : hsubst-val E0 ([x] pair (M x) (N x)) (pair M' N')
               <- hsubst-exp E0 M M'
               <- hsubst-exp E0 N N'.

hsubst/fst : hsubst-use E0 ([x] fst) fst.
hsubst/snd : hsubst-use E0 ([x] snd) snd.

hsubst/unit : hsubst-val E0 ([x] unit) unit.
hsubst/ax : hsubst-val E0 ([x] ax) ax.

hsubst/fun : hsubst-val E0 ([x] fun (A x) (B x)) (fun A' B')
              <- hsubst-exp E0 A A'
              <- hsubst-exp E0 B B'.
hsubst/lam : hsubst-val E0 ([x] lam ([y] E x y)) (lam E')
              <- {y} hsubst-exp E0 ([x] E x y) (E' y).
hsubst/ap : hsubst-use E0 ([x] ap (E x)) (ap E')
             <- hsubst-exp E0 E E'.

hsubst/closed : hsubst-neu E0 ([x] R) R.
hsubst/@ : hsubst-neu E0 ([x] (U x) @ (R x)) (U' @ R')
            <- hsubst-neu E0 R R'
            <- hsubst-use E0 U U'.

hsubst/` : hsubst-neu-exp E0 ([x] ` x) E0.
hsubst/⋄ : hsubst-neu-exp E0 ([x] (U x) @ (R x)) U⋄R
            <- hsubst-neu-exp E0 R (↑ M)
            <- hsubst-use E0 U U'
            <- happ U' M U⋄R.

hsubst/↑ : hsubst-exp E0 ([x] ↑ (M x)) (↑ N)
            <- hsubst-val E0 M N.
hsubst/↓/neu : hsubst-exp E0 ([x] ↓ (R x)) (↓ S)
                <- hsubst-neu E0 R S.
hsubst/↓/exp : hsubst-exp E0 ([x] ↓ (R x)) E
                <- hsubst-neu-exp E0 R E.
hsubst/let : hsubst-exp E0 ([x] let (E x) ([y] F x y)) (let E' F')
              <- hsubst-exp E0 E E'
              <- {y} hsubst-exp E0 ([x] F x y) (F' y).

chk/ax : ax <=₀ unit.
chk/pair : pair M N <=₀ prod A B
            <- hsubst-exp M B B'
            <- M <=* A
            <- N <=* B'.

uses/fst : uses fst (prod A B) ([x] A).
uses/snd : uses snd (prod A B) B'
            <- {x} hsubst-exp (↓ (fst @ ` x)) B (B' x).
happ/fst : happ fst (pair M N) M.
happ/snd : happ snd (pair M N) N.

chk/lam : lam E <=₀ fun A B
           <- {x} x =>₀ A -> E x <=* B.
uses/ap : uses (ap E) (fun A B) ([x] B)
           <- E <=* A.
happ/ap : happ (ap E) (lam F) F'
           <- hsubst-exp E F F'.

%%% We reduce expressions to weak head normal forms by replacing let bindings
%%% by (hereditary) substitutions.
whnf : exp -> exp -> type.
%mode whnf +E1 -E2.

whnf/↓ : whnf (↓ R) (↓ R).
whnf/↑ : whnf (↑ M) (↑ M).
whnf/let : whnf (let E F) X'
            <- hsubst-exp E F X
            <- whnf X X'.

%%% These are the primary typing checking & type synthesis
%%% judgements. The meaning of <=* is very similar to the meaning of ∈
%%% in extensional type theory: whereas in ETT, we whnfuate M to a
%%% canonical form and then check if it is a verification of A, in ITT
%%% we evaluate M to a normal form and see if it is a verification of
%%% A.

<=*/whnf : E <=* A
            <- whnf E E'
            <- whnf A A'
            <- E' <= A'.
=>*/whnf : R =>* A'
            <- R => A
            <- whnf A A'.

%abbrev ⋄ = [U] [X] let X ([x] ↓ (U @ ` x)). %infix left 0 ⋄.

%solve - : (↑ pair (↑ ax) (snd ⋄ ↑ pair (↑ ax) (↑ ax))) <=* ↑ prod (↑ unit) ([x] ↑ unit).
%solve - : (fst ⋄ ↑ pair (↑ ax) (↑ ax)) <=* ↑ unit.
%solve - : (let (↑ ax) [x] ↓ ` x) <=* ↑ unit.
%solve - : (↑ lam [x] ↓ ` x) <=* ↑ fun (↑ unit) (↑ unit).
%solve - : (ap (↑ ax) ⋄ ↑ lam [x] ↓ ` x) <=* ↑ unit.